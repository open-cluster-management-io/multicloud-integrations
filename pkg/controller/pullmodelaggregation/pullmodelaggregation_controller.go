/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pullmodelaggregation

import (
	"context"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/ghodss/yaml"
	"k8s.io/apimachinery/pkg/api/equality"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/klog"
	v1 "open-cluster-management.io/api/work/v1"
	appsetreportV1alpha1 "open-cluster-management.io/multicloud-integrations/pkg/apis/appsetreport/v1alpha1"
	"open-cluster-management.io/multicloud-integrations/pkg/utils"

	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"
)

// ReconcilePullModelAggregation reconciles a MulticlusterApplicationSet object.
type ReconcilePullModelAggregation struct {
	client.Client
	Interval int
}

// Keys for the appSetClusterStatusMap
type AppSet struct {
	appset types.NamespacedName
}

type Cluster struct {
	clusterName string
}

// Value for the appSetClusterStatusMap
type OverallStatus struct {
	HealthStatus string
	SyncStatus   string
}

// AppSetClusterResourceSorter sorts appsetreport resources by name
type AppSetClusterResourceSorter []appsetreportV1alpha1.ResourceRef

func (a AppSetClusterResourceSorter) Len() int           { return len(a) }
func (a AppSetClusterResourceSorter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a AppSetClusterResourceSorter) Less(i, j int) bool { return a[i].Name < a[j].Name }

// AppSetClusterConditionsSorter sorts appsetreport clusterconditions by cluster
type AppSetClusterConditionsSorter []appsetreportV1alpha1.ClusterCondition

func (a AppSetClusterConditionsSorter) Len() int           { return len(a) }
func (a AppSetClusterConditionsSorter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a AppSetClusterConditionsSorter) Less(i, j int) bool { return a[i].Cluster < a[j].Cluster }

func Add(mgr manager.Manager, interval int) error {
	dsRS := &ReconcilePullModelAggregation{
		Client:   mgr.GetClient(),
		Interval: interval,
	}

	return mgr.Add(dsRS)
}

func (r *ReconcilePullModelAggregation) Start(ctx context.Context) error {
	go wait.Until(func() {
		r.houseKeeping()
	}, time.Duration(r.Interval)*time.Second, ctx.Done())

	return nil
}

func (r *ReconcilePullModelAggregation) houseKeeping() {
	klog.Info("Start aggregating all ArgoCD application manifestworks per appset...")

	// create or update all MulticlusterApplicationSetReport objects in the appset NS
	err := r.generateAggregation()
	if err != nil {
		klog.Warning("error while generating ArgoCD application aggregation: ", err)
	}

	klog.Info("Finish aggregating all ArgoCD application manifestworks.")
}

func (r *ReconcilePullModelAggregation) generateAggregation() error {
	PrintMemUsage("Prepare to aggregate manifestwork statuses")

	appSetClusterList := &v1.ManifestWorkList{}
	listopts := &client.ListOptions{}

	appSetClusterSelector := &metav1.LabelSelector{
		MatchLabels: map[string]string{
			// need to change label need to talk to mike about it.
			"apps.open-cluster-management.io/multicluster-application-set": "true",
		},
	}

	appSetClusterLabels, err := utils.ConvertLabels(appSetClusterSelector)
	if err != nil {
		klog.Errorf("Failed to convert Argo Application manifestWork CR label selector, err: %v", err)

		return err
	}

	listopts.LabelSelector = appSetClusterLabels
	err = r.List(context.TODO(), appSetClusterList, listopts) // list all the manifestworks

	if err != nil {
		klog.Errorf("Failed to list Argo Application manifestWork CR, err: %v", err)

		return err
	}

	// above fetches manifestworks generated by the propagation controller.

	appSetClusterCount := len(appSetClusterList.Items)

	if appSetClusterCount == 0 {
		klog.Infof("No aggregration per cluster with labels %v found", appSetClusterSelector)

		return nil
	}

	klog.Infof("cluster aggregation Count: %v", appSetClusterCount)

	PrintMemUsage("Initialize AppSet Map.")

	// create a map for containing overallstatus per cluster, appset. 2 Keys Appset NamespacedName, Cluster Name
	appSetClusterStatusMap := make(map[AppSet]map[Cluster]OverallStatus)

	for _, manifestWork := range appSetClusterList.Items {
		appsetNs, appsetName := ParseNamespacedName(manifestWork.Annotations["hosting-applicationset"])
		if appsetNs == "" || appsetName == "" {
			klog.Warningf("Appset namespace: %v , Appset name: %v", appsetNs, appsetName)
		}

		// Need to allocate a map of clusters for each appset
		appSetKey := AppSet{types.NamespacedName{Namespace: appsetNs, Name: appsetName}}
		appSetClusterStatusMap[appSetKey] = make(map[Cluster]OverallStatus)
	}

	for _, manifestWork := range appSetClusterList.Items {
		healthStatus, syncStatus := "Unknown", "Unknown"

		appsetNs, appsetName := ParseNamespacedName(manifestWork.Annotations["hosting-applicationset"])
		if appsetNs == "" || appsetName == "" {
			klog.Warningf("Appset namespace: %v , Appset name: %v", appsetNs, appsetName)
		}

		appSetKey := AppSet{types.NamespacedName{Namespace: appsetNs, Name: appsetName}}
		clusterKey := Cluster{manifestWork.Namespace}

		for _, manifest := range manifestWork.Status.ResourceStatus.Manifests {
			for _, statuses := range manifest.StatusFeedbacks.Values {
				if statuses.Name == "healthStatus" {
					healthStatus = *statuses.Value.String
				} else if statuses.Name == "syncStatus" {
					syncStatus = *statuses.Value.String
				}
			}
		}

		appSetClusterStatusMap[appSetKey][clusterKey] = OverallStatus{
			HealthStatus: healthStatus,
			SyncStatus:   syncStatus,
		}
	}

	appSetClusterList = nil

	runtime.GC()

	PrintMemUsage("AppSet Map generated.")

	r.createOrUpdateAppSetReport(appSetClusterStatusMap)

	return nil
}

func (r *ReconcilePullModelAggregation) createOrUpdateAppSetReport(appSetClusterStatusMap map[AppSet]map[Cluster]OverallStatus) {
	for appset := range appSetClusterStatusMap {
		var (
			appSetClusterConditions                                      []appsetreportV1alpha1.ClusterCondition
			synced, notSynced, healthy, notHealthy, inProgress, clusters int
		)

		for cluster := range appSetClusterStatusMap[appset] {
			// generate the cluster condition list per this appset
			appSetClusterConditions = append(appSetClusterConditions, appsetreportV1alpha1.ClusterCondition{
				Cluster:      cluster.clusterName,
				SyncStatus:   appSetClusterStatusMap[appset][cluster].SyncStatus,
				HealthStatus: appSetClusterStatusMap[appset][cluster].HealthStatus,
			})

			// Calculate the summary while we're here.
			clusters++

			switch appSetClusterStatusMap[appset][cluster].HealthStatus {
			case "Healthy":
				healthy++
			case "Progressing":
				inProgress++
				notHealthy++
			default:
				notHealthy++
			}

			switch appSetClusterStatusMap[appset][cluster].SyncStatus {
			case "Synced":
				synced++
			default:
				notSynced++
			}
		}

		klog.V(1).Infof("Updating AppSetReport for appset: %v", appset)

		// Fetch the existing MulticlusterApplicationSetReport
		existingAppsetReport := &appsetreportV1alpha1.MulticlusterApplicationSetReport{
			TypeMeta: metav1.TypeMeta{
				Kind:       "MulticlusterApplicationSetReport",
				APIVersion: "apps.open-cluster-management.io/v1alpha1",
			},
		}
		// create/update the applicationset report for this appset
		//    1. create a new applicationseet report and assign it to a variable
		//    2. fetch the existing appset report,
		//    3. compare the existing one to the new one
		//    4. update the appset report only if there are changes

		if err := r.Get(context.TODO(), appset.appset, existingAppsetReport); err != nil { // this just overwrites what we just did lmao.
			if errors.IsNotFound(err) {
				klog.Errorf("Failed to find appsetReport err: %v", err)

				continue
			}
		}

		if clusters != (synced+notSynced) || clusters != (healthy+notHealthy) {
			klog.Warning("Invalid number of clusters")
		}

		newSummary := appsetreportV1alpha1.ReportSummary{
			Synced:     strconv.Itoa(synced),
			NotSynced:  strconv.Itoa(notSynced),
			Healthy:    strconv.Itoa(healthy),
			NotHealthy: strconv.Itoa(notHealthy),
			InProgress: strconv.Itoa(inProgress),
			Clusters:   strconv.Itoa(clusters),
		}
		appsetNs := appset.appset.Namespace
		appsetName := appset.appset.Name

		// load yaml from Resource Sync Controller
		appSetCRD, err := loadAppSetCRD(fmt.Sprintf("%.63s", appsetNs+"-"+appsetName) + ".yaml")
		if err != nil {
			klog.Fatal("Failed to load appSet CRD err: ", err)
		}

		newClusterConditions := append(appSetClusterConditions, appSetCRD.ClusterConditions...)

		newAppSetReport := r.newAppSetReport(appsetNs, appsetName, appSetCRD.Resources, newClusterConditions, newSummary)

		PrintMemUsage("memory usage when updating MulticlusterApplicationSetReport.")

		isSame := true

		if !equality.Semantic.DeepEqual(existingAppsetReport.GetLabels(), newAppSetReport.GetLabels()) {
			klog.V(1).Info("Labels not same")

			isSame = false
		}
		// need to confirm summary is same (this is going to require some refactoring)
		if !equality.Semantic.DeepEqual(existingAppsetReport.Statuses.Summary, newAppSetReport.Statuses.Summary) {
			klog.V(1).Info("Summary not same")

			isSame = false
		}
		// sort existing appset resources & clusterConditions by name
		// sort new appset resources & clusterConditions by name

		sort.Sort(AppSetClusterResourceSorter(existingAppsetReport.Statuses.Resources))
		sort.Sort(AppSetClusterConditionsSorter(existingAppsetReport.Statuses.ClusterConditions))
		sort.Sort(AppSetClusterResourceSorter(newAppSetReport.Statuses.Resources))
		sort.Sort(AppSetClusterConditionsSorter(newAppSetReport.Statuses.ClusterConditions))

		// check equality of resources & cluster conditions
		if !equality.Semantic.DeepEqual(existingAppsetReport.Statuses.Resources, newAppSetReport.Statuses.Resources) {
			klog.V(1).Info("Resources not same")

			isSame = false
		}

		if !equality.Semantic.DeepEqual(existingAppsetReport.Statuses.ClusterConditions, newAppSetReport.Statuses.ClusterConditions) {
			klog.V(1).Info("ClusterConditions not same")

			isSame = false
		}

		if !isSame {
			existingAppsetReport.SetName(newAppSetReport.GetName())
			existingAppsetReport.SetNamespace(newAppSetReport.GetNamespace())
			existingAppsetReport.SetLabels(newAppSetReport.GetLabels())

			existingAppsetReport.Statuses.Resources = newAppSetReport.Statuses.Resources

			existingAppsetReport.Statuses.ClusterConditions = newAppSetReport.Statuses.ClusterConditions

			existingAppsetReport.Statuses.Summary = newAppSetReport.Statuses.Summary

			if err := r.Update(context.TODO(), existingAppsetReport); err != nil {
				klog.Errorf("Failed to update MulticlusterApplicationSetReport err: %v", err)

				continue
			}

			klog.V(1).Infof("MulticlusterApplicationSetReport updated, %v/%v", existingAppsetReport.GetNamespace(), existingAppsetReport.GetName())
		}
	}
}

func (r *ReconcilePullModelAggregation) newAppSetReport(appsetNs, appsetName string, appsetResources []appsetreportV1alpha1.ResourceRef,
	appsetClusterConditions []appsetreportV1alpha1.ClusterCondition,
	appsetSummary appsetreportV1alpha1.ReportSummary) *appsetreportV1alpha1.MulticlusterApplicationSetReport {
	newAppSetReport := &appsetreportV1alpha1.MulticlusterApplicationSetReport{
		TypeMeta: metav1.TypeMeta{
			Kind:       "MulticlusterApplicationSetReport",
			APIVersion: "apps.open-cluster-management.io/v1alpha1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      appsetName,
			Namespace: appsetNs,
			Labels: map[string]string{
				"apps.open-cluster-management.io/hosting-applicationset": fmt.Sprintf("%.63s", appsetNs+"."+appsetName),
			},
		},
		Statuses: appsetreportV1alpha1.AppConditions{
			Resources:         appsetResources,
			ClusterConditions: appsetClusterConditions,
			Summary:           appsetSummary,
		},
	}

	return newAppSetReport
}

func loadAppSetCRD(pathname string) (*appsetreportV1alpha1.AppConditions, error) {
	var (
		err     error
		crddata []byte
		crdobj  appsetreportV1alpha1.AppConditions
	)

	crddata, err = ioutil.ReadFile(filepath.Clean(pathname))

	if err != nil {
		klog.Fatal("Loading appconditions crd ", err.Error())
		return nil, err
	}

	err = yaml.Unmarshal(crddata, &crdobj)

	if err != nil {
		klog.Fatal("Unmarshal appconditions crd ", err.Error(), "\n", string(crddata))
		return nil, err
	}

	return &crdobj, nil
}

func ParseNamespacedName(namespacedName string) (string, string) {
	parsedstr := strings.Split(namespacedName, "/")

	if len(parsedstr) != 2 {
		klog.Infof("invalid namespacedName: %v", namespacedName)
		return "", ""
	}

	return parsedstr[0], parsedstr[1]
}

func PrintMemUsage(title string) {
	var m runtime.MemStats

	runtime.ReadMemStats(&m)

	// For info on each, see: https://golang.org/pkg/runtime/#MemStats
	klog.Infof("%v", title)
	klog.Infof("Alloc = %v MiB", bToMb(m.Alloc))
	klog.Infof("\tTotalAlloc = %v MiB", bToMb(m.TotalAlloc))
	klog.Infof("\tSys = %v MiB", bToMb(m.Sys))
	klog.Infof("\tNumGC = %v\n", m.NumGC)
}

func bToMb(b uint64) uint64 {
	return b / 1024 / 1024
}
