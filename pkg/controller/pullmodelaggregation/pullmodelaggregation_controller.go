/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pullmodelaggregation

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/ghodss/yaml"
	"k8s.io/apimachinery/pkg/api/equality"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/selection"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/klog"
	v1 "open-cluster-management.io/api/work/v1"
	appsetreportV1alpha1 "open-cluster-management.io/multicloud-integrations/pkg/apis/appsetreport/v1alpha1"

	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"
)

// ReconcilePullModelAggregation reconciles a MulticlusterApplicationSet object.
type ReconcilePullModelAggregation struct {
	client.Client
	Interval    int
	ResourceDir string
}

// Keys for the appSetClusterStatusMap
type AppSet struct {
	appset types.NamespacedName
}

type Cluster struct {
	clusterName string
}

// Value for the appSetClusterStatusMap
type OverallStatus struct {
	HealthStatus string
	SyncStatus   string
}

// AppSetClusterResourceSorter sorts appsetreport resources by name
type AppSetClusterResourceSorter []appsetreportV1alpha1.ResourceRef

func (a AppSetClusterResourceSorter) Len() int           { return len(a) }
func (a AppSetClusterResourceSorter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a AppSetClusterResourceSorter) Less(i, j int) bool { return a[i].Name < a[j].Name }

// AppSetClusterConditionsSorter sorts appsetreport clusterconditions by cluster
type AppSetClusterConditionsSorter []appsetreportV1alpha1.ClusterCondition

func (a AppSetClusterConditionsSorter) Len() int           { return len(a) }
func (a AppSetClusterConditionsSorter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a AppSetClusterConditionsSorter) Less(i, j int) bool { return a[i].Cluster < a[j].Cluster }

func Add(mgr manager.Manager, interval int, resourceDir string) error {
	dsRS := &ReconcilePullModelAggregation{
		Client:      mgr.GetClient(),
		Interval:    interval,
		ResourceDir: resourceDir,
	}

	return mgr.Add(dsRS)
}

func (r *ReconcilePullModelAggregation) Start(ctx context.Context) error {
	go wait.Until(func() {
		r.houseKeeping()
	}, time.Duration(r.Interval)*time.Second, ctx.Done())

	return nil
}

func (r *ReconcilePullModelAggregation) houseKeeping() {
	klog.Info("Start aggregating all ArgoCD application manifestworks per appset...")

	// create or update all MulticlusterApplicationSetReport objects in the appset NS
	err := r.generateAggregation()
	if err != nil {
		klog.Warning("error while generating ArgoCD application aggregation: ", err)
	}

	klog.Info("Finish aggregating all ArgoCD application manifestworks.")
}

func (r *ReconcilePullModelAggregation) generateAggregation() error {
	PrintMemUsage("Prepare to aggregate manifestwork statuses")

	appSetClusterList := &v1.ManifestWorkList{}
	listopts := &client.ListOptions{}

	appSetRequirement, err := labels.NewRequirement("apps.open-cluster-management.io/application-set", selection.Exists, []string{})
	if err != nil {
		klog.Errorf("bad requirement: %v", err)
	}

	appSetSelector := labels.NewSelector()
	appSetSelector = appSetSelector.Add(*appSetRequirement)
	listopts.LabelSelector = appSetSelector

	err = r.List(context.TODO(), appSetClusterList, listopts) // list all the manifestworks
	if err != nil {
		klog.Errorf("Failed to list Argo Application manifestWork CR, err: %v", err)

		return err
	}

	// above fetches manifestworks generated by the propagation controller.
	appSetClusterCount := len(appSetClusterList.Items)

	if appSetClusterCount == 0 {
		klog.Infof("No aggregration per cluster with labels %v found", appSetSelector)

		return nil
	}

	klog.Infof("cluster aggregation Count: %v", appSetClusterCount)

	PrintMemUsage("Initialize AppSet Map.")

	// create a map for containing overallstatus per cluster, appset. 2 Keys Appset NamespacedName, Cluster Name
	appSetClusterStatusMap := make(map[AppSet]map[Cluster]OverallStatus)

	for _, manifestWork := range appSetClusterList.Items {
		appsetNs, appsetName := ParseNamespacedName(manifestWork.Annotations["hosting-applicationset"])
		if appsetNs == "" || appsetName == "" {
			klog.Warningf("Appset namespace: %v , Appset name: %v", appsetNs, appsetName)
		}

		// Need to allocate a map of clusters for each appset
		appSetKey := AppSet{types.NamespacedName{Namespace: appsetNs, Name: appsetName}}
		appSetClusterStatusMap[appSetKey] = make(map[Cluster]OverallStatus)
	}

	for _, manifestWork := range appSetClusterList.Items {
		healthStatus, syncStatus := "Unknown", "Unknown"

		appsetNs, appsetName := ParseNamespacedName(manifestWork.Annotations["hosting-applicationset"])
		if appsetNs == "" && appsetName == "" {
			klog.Warningf("Appset namespace: %v , Appset name: %v", appsetNs, appsetName)
		}

		appSetKey := AppSet{types.NamespacedName{Namespace: appsetNs, Name: appsetName}}
		clusterKey := Cluster{manifestWork.Namespace}

		for _, manifest := range manifestWork.Status.ResourceStatus.Manifests {
			for _, statuses := range manifest.StatusFeedbacks.Values {
				if statuses.Name == "healthStatus" {
					healthStatus = *statuses.Value.String
				} else if statuses.Name == "syncStatus" {
					syncStatus = *statuses.Value.String
				}
			}
		}

		appSetClusterStatusMap[appSetKey][clusterKey] = OverallStatus{
			HealthStatus: healthStatus,
			SyncStatus:   syncStatus,
		}
	}

	appSetClusterList = nil

	runtime.GC()

	PrintMemUsage("AppSet Map generated.")

	// generate report with just overallstatus
	r.generateAppSetReport(appSetClusterStatusMap, false)

	// generate report again this time with resources and conditions from resource sync controller.
	r.generateAppSetReport(appSetClusterStatusMap, true)

	runtime.GC()

	PrintMemUsage("AppSet Report refreshed.")

	return nil
}

func (r *ReconcilePullModelAggregation) generateAppSetReport(appSetClusterStatusMap map[AppSet]map[Cluster]OverallStatus, loadYAML bool) {
	for appset := range appSetClusterStatusMap {
		createAppSetReport := false
		appsetNs := appset.appset.Namespace
		appsetName := appset.appset.Name

		// create/update the applicationset report for this appset
		klog.V(1).Infof("Updating AppSetReport for appset: %v", appset)

		//    1. create a new applicationseet report and assign it to a variable
		existingAppsetReport := &appsetreportV1alpha1.MulticlusterApplicationSetReport{
			TypeMeta: metav1.TypeMeta{
				Kind:       "MulticlusterApplicationSetReport",
				APIVersion: "apps.open-cluster-management.io/v1alpha1",
			},
		}

		//    2. fetch the existing appset report
		if err := r.Get(context.TODO(), appset.appset, existingAppsetReport); err != nil {
			if errors.IsNotFound(err) {
				// Create report for the first time
				existingAppsetReport.ObjectMeta = metav1.ObjectMeta{
					Name:      appsetName,
					Namespace: appsetNs,
					Labels: map[string]string{
						"apps.open-cluster-management.io/hosting-applicationset": fmt.Sprintf("%.63s", appsetNs+"."+appsetName),
					},
				}

				createAppSetReport = true

				if err := r.Create(context.TODO(), existingAppsetReport); err != nil {
					if errors.IsAlreadyExists(err) {
						klog.Errorf("Failed to create the appsetReport, err: %v", err)

						continue
					}
				}
			}
		}

		// load yaml from Resource Sync Controller
		var newAppSetReport *appsetreportV1alpha1.MulticlusterApplicationSetReport

		if loadYAML {
			reportName := filepath.Join(r.ResourceDir, fmt.Sprintf("%.63s", appsetNs+"-"+appsetName)+".yaml")
			appSetCRD, err := loadAppSetCRD(reportName)

			if err != nil {
				klog.Warning("Failed to load appSet CRD err: ", err)

				// controller may be taking a while in this case just skip trying to update the report.
				continue
			}

			newSummary, appSetClusterConditions := r.generateSummary(appSetClusterStatusMap, appset, appSetCRD.ClusterConditions)
			newAppSetReport = r.newAppSetReport(appsetNs, appsetName, appSetCRD.Resources, appSetClusterConditions, newSummary)
		} else {
			newSummary, appSetClusterConditions := r.generateSummary(appSetClusterStatusMap, appset, []appsetreportV1alpha1.ClusterCondition{})
			newAppSetReport = r.newAppSetReport(appsetNs, appsetName, []appsetreportV1alpha1.ResourceRef{}, appSetClusterConditions, newSummary)
		}

		PrintMemUsage("memory usage when updating MulticlusterApplicationSetReport.")

		//    3. compare the existing one to the new one
		// If the appsetReport was recently created need to fetch the new copy.
		if createAppSetReport {
			if err := r.Get(context.TODO(), appset.appset, existingAppsetReport); err != nil {
				if errors.IsNotFound(err) {
					klog.Errorf("Failed to get the appsetReport, err: %v", err)

					continue
				}
			}
		}

		if !r.compareAppSetReports(existingAppsetReport, newAppSetReport) {
			//    4. update the appset report only if there are changes
			existingAppsetReport.SetName(newAppSetReport.GetName())
			existingAppsetReport.SetNamespace(newAppSetReport.GetNamespace())
			existingAppsetReport.SetLabels(newAppSetReport.GetLabels())

			existingAppsetReport.Statuses.Resources = newAppSetReport.Statuses.Resources

			existingAppsetReport.Statuses.ClusterConditions = newAppSetReport.Statuses.ClusterConditions

			existingAppsetReport.Statuses.Summary = newAppSetReport.Statuses.Summary

			if err := r.Update(context.TODO(), existingAppsetReport); err != nil {
				klog.Errorf("Failed to update MulticlusterApplicationSetReport err: %v", err)

				continue
			}

			klog.V(1).Infof("MulticlusterApplicationSetReport updated, %v/%v", existingAppsetReport.GetNamespace(), existingAppsetReport.GetName())
		}
	}
}

func (r *ReconcilePullModelAggregation) generateSummary(appSetClusterStatusMap map[AppSet]map[Cluster]OverallStatus,
	appset AppSet, appSetCRDConditions []appsetreportV1alpha1.ClusterCondition) (appsetreportV1alpha1.ReportSummary, []appsetreportV1alpha1.ClusterCondition) {
	var (
		appSetClusterConditions                                      []appsetreportV1alpha1.ClusterCondition
		synced, notSynced, healthy, notHealthy, inProgress, clusters int
	)

	for cluster := range appSetClusterStatusMap[appset] {
		// generate the cluster condition list per this appset
		appSetClusterConditions = append(appSetClusterConditions, appsetreportV1alpha1.ClusterCondition{
			Cluster:      cluster.clusterName,
			SyncStatus:   appSetClusterStatusMap[appset][cluster].SyncStatus,
			HealthStatus: appSetClusterStatusMap[appset][cluster].HealthStatus,
		})

		// Calculate the summary while we're here.
		clusters++

		switch appSetClusterStatusMap[appset][cluster].HealthStatus {
		case "Healthy":
			healthy++
		case "Progressing":
			inProgress++
			notHealthy++
		default:
			notHealthy++
		}

		switch appSetClusterStatusMap[appset][cluster].SyncStatus {
		case "Synced":
			synced++
		default:
			notSynced++
		}
	}

	if clusters != (synced+notSynced) || clusters != (healthy+notHealthy) {
		klog.Warning("Total number of clusters does not add up")
	}

	// Need to merge the cluster conditions from the manifestwork & yaml
	// 1.     combine each condition into a single list
	// 2. 	  loop through list, adding entries to a map
	// 3. 	  upon a condition that already exists, add remaining info to entry
	//     3a.	  doesn't exist in map, add cluster condition as is
	//     3b.    cluster does exist in map, add missing information
	// 4. 	  loop through map, creating a new list grabbing the entire clustercondition entry
	// 5. 	  sort the new list to be in a natural order.

	combinedList := append(appSetClusterConditions, appSetCRDConditions...)
	dict := make(map[string]appsetreportV1alpha1.ClusterCondition)
	res := make([]appsetreportV1alpha1.ClusterCondition, 0)

	for _, condition := range combinedList {
		if _, ok := dict[condition.Cluster]; ok {
			v := dict[condition.Cluster]
			if condition.HealthStatus != "" {
				v.HealthStatus = condition.HealthStatus
			}

			if condition.SyncStatus != "" {
				v.SyncStatus = condition.SyncStatus
			}

			if condition.Conditions != nil {
				v.Conditions = condition.Conditions
			}

			dict[condition.Cluster] = v
		} else {
			dict[condition.Cluster] = condition
		}
	}

	for _, condition := range dict {
		res = append(res, condition)
	}

	// Sort after list has been created so it's in a natural order
	sort.Sort(AppSetClusterConditionsSorter(res))

	return appsetreportV1alpha1.ReportSummary{
		Synced:     strconv.Itoa(synced),
		NotSynced:  strconv.Itoa(notSynced),
		Healthy:    strconv.Itoa(healthy),
		NotHealthy: strconv.Itoa(notHealthy),
		InProgress: strconv.Itoa(inProgress),
		Clusters:   strconv.Itoa(clusters),
	}, res
}

func (r *ReconcilePullModelAggregation) newAppSetReport(appsetNs, appsetName string, appsetResources []appsetreportV1alpha1.ResourceRef,
	appsetClusterConditions []appsetreportV1alpha1.ClusterCondition,
	appsetSummary appsetreportV1alpha1.ReportSummary) *appsetreportV1alpha1.MulticlusterApplicationSetReport {
	newAppSetReport := &appsetreportV1alpha1.MulticlusterApplicationSetReport{
		TypeMeta: metav1.TypeMeta{
			Kind:       "MulticlusterApplicationSetReport",
			APIVersion: "apps.open-cluster-management.io/v1alpha1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      appsetName,
			Namespace: appsetNs,
			Labels: map[string]string{
				"apps.open-cluster-management.io/hosting-applicationset": fmt.Sprintf("%.63s", appsetNs+"."+appsetName),
			},
		},
		Statuses: appsetreportV1alpha1.AppConditions{
			Resources:         appsetResources,
			ClusterConditions: appsetClusterConditions,
			Summary:           appsetSummary,
		},
	}

	return newAppSetReport
}

func (r *ReconcilePullModelAggregation) compareAppSetReports(report1, report2 *appsetreportV1alpha1.MulticlusterApplicationSetReport) bool {
	isSame := true

	if !equality.Semantic.DeepEqual(report1.GetLabels(), report2.GetLabels()) {
		klog.V(1).Info("Labels not same")

		isSame = false
	}

	if !equality.Semantic.DeepEqual(report1.Statuses.Summary, report2.Statuses.Summary) {
		klog.V(1).Info("Summary not same")

		isSame = false
	}

	if len(report1.Statuses.Resources) != len(report2.Statuses.Resources) {
		klog.V(1).Info("Resources not same")

		isSame = false
	} else {
		// sort new appset resources & clusterConditions by name
		sort.Sort(AppSetClusterResourceSorter(report1.Statuses.Resources))
		sort.Sort(AppSetClusterResourceSorter(report2.Statuses.Resources))

		// check equality of resources
		if !equality.Semantic.DeepEqual(report1.Statuses.Resources, report2.Statuses.Resources) {
			klog.V(1).Info("Resources not same")

			isSame = false
		}
	}

	if len(report1.Statuses.ClusterConditions) != len(report2.Statuses.ClusterConditions) {
		klog.V(1).Info("ClusterConditions not same")

		isSame = false
	} else {
		// sort existing appset resources & clusterConditions by name
		sort.Sort(AppSetClusterConditionsSorter(report1.Statuses.ClusterConditions))
		sort.Sort(AppSetClusterConditionsSorter(report2.Statuses.ClusterConditions))

		// check equality of clusterConditions
		if !equality.Semantic.DeepEqual(report1.Statuses.ClusterConditions, report2.Statuses.ClusterConditions) {
			klog.V(1).Info("ClusterConditions not same")

			isSame = false
		}
	}

	return isSame
}

func loadAppSetCRD(pathname string) (*appsetreportV1alpha1.AppConditions, error) {
	var (
		err     error
		crddata []byte
		crdobj  appsetreportV1alpha1.AppConditions
	)

	crddata, err = os.ReadFile(filepath.Clean(pathname))

	if err != nil {
		klog.Error("Loading appconditions crd ", err.Error())
		return nil, err
	}

	err = yaml.Unmarshal(crddata, &crdobj)

	if err != nil {
		klog.Error("Unmarshal appconditions crd ", err.Error(), "\n", string(crddata))
		return nil, err
	}

	return &crdobj, nil
}

func ParseNamespacedName(namespacedName string) (string, string) {
	parsedstr := strings.Split(namespacedName, "/")

	if len(parsedstr) != 2 {
		klog.Infof("invalid namespacedName: %v", namespacedName)
		return "", ""
	}

	return parsedstr[0], parsedstr[1]
}

func PrintMemUsage(title string) {
	var m runtime.MemStats

	runtime.ReadMemStats(&m)

	// For info on each, see: https://golang.org/pkg/runtime/#MemStats
	klog.Infof("%v", title)
	klog.Infof("Alloc = %v MiB", bToMb(m.Alloc))
	klog.Infof("\tTotalAlloc = %v MiB", bToMb(m.TotalAlloc))
	klog.Infof("\tSys = %v MiB", bToMb(m.Sys))
	klog.Infof("\tNumGC = %v\n", m.NumGC)
}

func bToMb(b uint64) uint64 {
	return b / 1024 / 1024
}
