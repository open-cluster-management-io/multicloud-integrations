/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pullmodelaggregation

import (
	"context"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/ghodss/yaml"
	"k8s.io/apimachinery/pkg/api/equality"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/klog"
	v1 "open-cluster-management.io/api/work/v1"
	appsetreportV1alpha1 "open-cluster-management.io/multicloud-integrations/pkg/apis/appsetreport/v1alpha1"
	"open-cluster-management.io/multicloud-integrations/pkg/utils"

	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"
)

// ReconcilePullModelAggregation reconciles a MulticlusterApplicationSet object.
type ReconcilePullModelAggregation struct {
	client.Client
	Interval int
}

// Keys for the appSetClusterStatusMap
type AppSet struct {
	appset types.NamespacedName
}

type Cluster struct {
	clusterName string
}

// Value for the appSetClusterStatusMap
type OverallStatus struct {
	HealthStatus string
	SyncStatus   string
}

// AppSetClusterResourceSorter sorts appsetreport resources by name
type AppSetClusterResourceSorter []appsetreportV1alpha1.ResourceRef

func (a AppSetClusterResourceSorter) Len() int           { return len(a) }
func (a AppSetClusterResourceSorter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a AppSetClusterResourceSorter) Less(i, j int) bool { return a[i].Name < a[j].Name }

// AppSetClusterConditionsSorter sorts appsetreport clusterconditions by cluster
type AppSetClusterConditionsSorter []appsetreportV1alpha1.ClusterCondition

func (a AppSetClusterConditionsSorter) Len() int           { return len(a) }
func (a AppSetClusterConditionsSorter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a AppSetClusterConditionsSorter) Less(i, j int) bool { return a[i].Cluster < a[j].Cluster }

func Add(mgr manager.Manager, interval int) error {
	dsRS := &ReconcilePullModelAggregation{
		Client:   mgr.GetClient(),
		Interval: interval,
	}

	return mgr.Add(dsRS)
}

func (r *ReconcilePullModelAggregation) Start(ctx context.Context) error {
	go wait.Until(func() {
		r.houseKeeping()
	}, time.Duration(r.Interval)*time.Second, ctx.Done())

	return nil
}

func (r *ReconcilePullModelAggregation) houseKeeping() {
	klog.Info("Start aggregating all ArgoCD application manifestworks per appset...")

	// create or update all MulticlusterApplicationSetReport objects in the appset NS
	err := r.generateAggregation()
	if err != nil {
		klog.Warning("error while generating ArgoCD application aggregation: ", err)
	}

	klog.Info("Finish aggregating all ArgoCD application manifestworks.")
}

func (r *ReconcilePullModelAggregation) generateAggregation() error {
	PrintMemUsage("Prepare to aggregate manifestwork statuses")

	appSetClusterList := &v1.ManifestWorkList{}
	listopts := &client.ListOptions{}

	appSetClusterSelector := &metav1.LabelSelector{
		MatchLabels: map[string]string{
			// need to change label need to talk to mike about it.
			"apps.open-cluster-management.io/multicluster-application-set": "true",
		},
	}

	appSetClusterLabels, err := utils.ConvertLabels(appSetClusterSelector)
	if err != nil {
		klog.Errorf("Failed to convert Argo Application manifestWork CR label selector, err: %v", err)

		return err
	}

	listopts.LabelSelector = appSetClusterLabels
	err = r.List(context.TODO(), appSetClusterList, listopts) // list all the manifestworks

	if err != nil {
		klog.Errorf("Failed to list Argo Application manifestWork CR, err: %v", err)

		return err
	}

	// above fetches manifestworks generated by the propagation controller.

	appSetClusterCount := len(appSetClusterList.Items)

	if appSetClusterCount == 0 {
		klog.Infof("No aggregration per cluster with labels %v found", appSetClusterSelector)

		return nil
	}

	klog.Infof("cluster aggregation Count: %v", appSetClusterCount)

	PrintMemUsage("Initialize AppSet Map.")

	// create a map for containing overallstatus per cluster, appset. 2 Keys Appset NamespacedName, Cluster Name
	appSetClusterStatusMap := make(map[AppSet]map[Cluster]OverallStatus)

	for _, manifestWork := range appSetClusterList.Items {
		appsetNs, appsetName := ParseNamespacedName(manifestWork.Annotations["hosting-applicationset"])
		if appsetNs == "" || appsetName == "" {
			klog.Warningf("Appset namespace: %v , Appset name: %v", appsetNs, appsetName)
		}

		// Need to allocate a map of clusters for each appset
		appSetKey := AppSet{types.NamespacedName{Namespace: appsetNs, Name: appsetName}}
		appSetClusterStatusMap[appSetKey] = make(map[Cluster]OverallStatus)
	}

	for _, manifestWork := range appSetClusterList.Items {
		healthStatus, syncStatus := "Unknown", "Unknown"

		appsetNs, appsetName := ParseNamespacedName(manifestWork.Annotations["hosting-applicationset"])
		if appsetNs == "" || appsetName == "" {
			klog.Warningf("Appset namespace: %v , Appset name: %v", appsetNs, appsetName)
		}

		appSetKey := AppSet{types.NamespacedName{Namespace: appsetNs, Name: appsetName}}
		clusterKey := Cluster{manifestWork.Namespace}

		for _, manifest := range manifestWork.Status.ResourceStatus.Manifests {
			for _, statuses := range manifest.StatusFeedbacks.Values {
				if statuses.Name == "healthStatus" {
					healthStatus = *statuses.Value.String
				} else if statuses.Name == "syncStatus" {
					syncStatus = *statuses.Value.String
				}
			}
		}

		appSetClusterStatusMap[appSetKey][clusterKey] = OverallStatus{
			HealthStatus: healthStatus,
			SyncStatus:   syncStatus,
		}
	}

	appSetClusterList = nil

	runtime.GC()

	PrintMemUsage("AppSet Map generated.")

	// generate report with just overallstatus
	r.generateAppSetReport(appSetClusterStatusMap)

	// generate report again this time with resources and conditions from resource sync controller.
	r.generateAppSetReportWithResources(appSetClusterStatusMap)

	return nil
}

func (r *ReconcilePullModelAggregation) generateAppSetReport(appSetClusterStatusMap map[AppSet]map[Cluster]OverallStatus) {
	for appset := range appSetClusterStatusMap {
		appsetNs := appset.appset.Namespace
		appsetName := appset.appset.Name

		newSummary, appSetClusterConditions := r.generateSummary(appSetClusterStatusMap, appset)

		// create/update the applicationset report for this appset
		klog.V(1).Infof("Updating AppSetReport for appset: %v", appset)

		//    1. create a new applicationseet report and assign it to a variable
		existingAppsetReport := &appsetreportV1alpha1.MulticlusterApplicationSetReport{
			TypeMeta: metav1.TypeMeta{
				Kind:       "MulticlusterApplicationSetReport",
				APIVersion: "apps.open-cluster-management.io/v1alpha1",
			},
		}

		//    2. fetch the existing appset report
		if err := r.Get(context.TODO(), appset.appset, existingAppsetReport); err != nil {
			if errors.IsNotFound(err) {
				klog.Errorf("Failed to find appsetReport err: %v", err)

				continue
			}
		}

		newAppSetReport := r.newAppSetReport(appsetNs, appsetName, []appsetreportV1alpha1.ResourceRef{}, appSetClusterConditions, newSummary)

		PrintMemUsage("memory usage when updating MulticlusterApplicationSetReport.")

		//    3. compare the existing one to the new one
		if !r.compareAppSetReports(existingAppsetReport, newAppSetReport) {
			//    4. update the appset report only if there are changes
			existingAppsetReport.SetName(newAppSetReport.GetName())
			existingAppsetReport.SetNamespace(newAppSetReport.GetNamespace())
			existingAppsetReport.SetLabels(newAppSetReport.GetLabels())

			existingAppsetReport.Statuses.Resources = newAppSetReport.Statuses.Resources

			existingAppsetReport.Statuses.ClusterConditions = newAppSetReport.Statuses.ClusterConditions

			existingAppsetReport.Statuses.Summary = newAppSetReport.Statuses.Summary

			if err := r.Update(context.TODO(), existingAppsetReport); err != nil {
				klog.Errorf("Failed to update MulticlusterApplicationSetReport err: %v", err)

				continue
			}

			klog.V(1).Infof("MulticlusterApplicationSetReport updated, %v/%v", existingAppsetReport.GetNamespace(), existingAppsetReport.GetName())
		}
	}
}

func (r *ReconcilePullModelAggregation) generateAppSetReportWithResources(appSetClusterStatusMap map[AppSet]map[Cluster]OverallStatus) {
	for appset := range appSetClusterStatusMap {
		appsetNs := appset.appset.Namespace
		appsetName := appset.appset.Name

		// load yaml from Resource Sync Controller
		appSetCRD, err := loadAppSetCRD(fmt.Sprintf("%.63s", appsetNs+"-"+appsetName) + ".yaml")
		if err != nil {
			klog.Warning("Failed to load appSet CRD err: ", err)

			// controller may be taking a while in this case just skip trying to update the report.
			continue
		}

		newSummary, appSetClusterConditions := r.generateSummary(appSetClusterStatusMap, appset)

		// create/update the applicationset report for this appset
		klog.V(1).Infof("Updating AppSetReport for appset: %v", appset)

		//    1. create a new applicationseet report and assign it to a variable
		existingAppsetReport := &appsetreportV1alpha1.MulticlusterApplicationSetReport{
			TypeMeta: metav1.TypeMeta{
				Kind:       "MulticlusterApplicationSetReport",
				APIVersion: "apps.open-cluster-management.io/v1alpha1",
			},
		}

		//    2. fetch the existing appset report
		if err := r.Get(context.TODO(), appset.appset, existingAppsetReport); err != nil {
			if errors.IsNotFound(err) {
				klog.Errorf("Failed to find appsetReport err: %v", err)

				continue
			}
		}

		newClusterConditions := append(appSetClusterConditions, appSetCRD.ClusterConditions...)
		newAppSetReport := r.newAppSetReport(appsetNs, appsetName, appSetCRD.Resources, newClusterConditions, newSummary)

		PrintMemUsage("memory usage when updating MulticlusterApplicationSetReport.")

		//    3. compare the existing one to the new one
		if !r.compareAppSetReports(existingAppsetReport, newAppSetReport) {
			//    4. update the appset report only if there are changes
			existingAppsetReport.SetName(newAppSetReport.GetName())
			existingAppsetReport.SetNamespace(newAppSetReport.GetNamespace())
			existingAppsetReport.SetLabels(newAppSetReport.GetLabels())

			existingAppsetReport.Statuses.Resources = newAppSetReport.Statuses.Resources

			existingAppsetReport.Statuses.ClusterConditions = newAppSetReport.Statuses.ClusterConditions

			existingAppsetReport.Statuses.Summary = newAppSetReport.Statuses.Summary

			if err := r.Update(context.TODO(), existingAppsetReport); err != nil {
				klog.Errorf("Failed to update MulticlusterApplicationSetReport err: %v", err)

				continue
			}

			klog.V(1).Infof("MulticlusterApplicationSetReport updated, %v/%v", existingAppsetReport.GetNamespace(), existingAppsetReport.GetName())
		}
	}
}

func (r *ReconcilePullModelAggregation) generateSummary(appSetClusterStatusMap map[AppSet]map[Cluster]OverallStatus,
	appset AppSet) (appsetreportV1alpha1.ReportSummary, []appsetreportV1alpha1.ClusterCondition) {
	var (
		appSetClusterConditions                                      []appsetreportV1alpha1.ClusterCondition
		synced, notSynced, healthy, notHealthy, inProgress, clusters int
	)

	for cluster := range appSetClusterStatusMap[appset] {
		// generate the cluster condition list per this appset
		appSetClusterConditions = append(appSetClusterConditions, appsetreportV1alpha1.ClusterCondition{
			Cluster:      cluster.clusterName,
			SyncStatus:   appSetClusterStatusMap[appset][cluster].SyncStatus,
			HealthStatus: appSetClusterStatusMap[appset][cluster].HealthStatus,
		})

		// Calculate the summary while we're here.
		clusters++

		switch appSetClusterStatusMap[appset][cluster].HealthStatus {
		case "Healthy":
			healthy++
		case "Progressing":
			inProgress++
			notHealthy++
		default:
			notHealthy++
		}

		switch appSetClusterStatusMap[appset][cluster].SyncStatus {
		case "Synced":
			synced++
		default:
			notSynced++
		}
	}

	if clusters != (synced+notSynced) || clusters != (healthy+notHealthy) {
		klog.Warning("Total number of clusters does not add up")
	}

	return appsetreportV1alpha1.ReportSummary{
		Synced:     strconv.Itoa(synced),
		NotSynced:  strconv.Itoa(notSynced),
		Healthy:    strconv.Itoa(healthy),
		NotHealthy: strconv.Itoa(notHealthy),
		InProgress: strconv.Itoa(inProgress),
		Clusters:   strconv.Itoa(clusters),
	}, appSetClusterConditions
}

func (r *ReconcilePullModelAggregation) newAppSetReport(appsetNs, appsetName string, appsetResources []appsetreportV1alpha1.ResourceRef,
	appsetClusterConditions []appsetreportV1alpha1.ClusterCondition,
	appsetSummary appsetreportV1alpha1.ReportSummary) *appsetreportV1alpha1.MulticlusterApplicationSetReport {
	newAppSetReport := &appsetreportV1alpha1.MulticlusterApplicationSetReport{
		TypeMeta: metav1.TypeMeta{
			Kind:       "MulticlusterApplicationSetReport",
			APIVersion: "apps.open-cluster-management.io/v1alpha1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      appsetName,
			Namespace: appsetNs,
			Labels: map[string]string{
				"apps.open-cluster-management.io/hosting-applicationset": fmt.Sprintf("%.63s", appsetNs+"."+appsetName),
			},
		},
		Statuses: appsetreportV1alpha1.AppConditions{
			Resources:         appsetResources,
			ClusterConditions: appsetClusterConditions,
			Summary:           appsetSummary,
		},
	}

	return newAppSetReport
}

func (r *ReconcilePullModelAggregation) compareAppSetReports(report1, report2 *appsetreportV1alpha1.MulticlusterApplicationSetReport) bool {
	isSame := true

	if !equality.Semantic.DeepEqual(report1.GetLabels(), report2.GetLabels()) {
		klog.V(1).Info("Labels not same")

		isSame = false
	}

	if !equality.Semantic.DeepEqual(report1.Statuses.Summary, report2.Statuses.Summary) {
		klog.V(1).Info("Summary not same")

		isSame = false
	}

	// sort existing appset resources & clusterConditions by name
	// sort new appset resources & clusterConditions by name
	sort.Sort(AppSetClusterResourceSorter(report1.Statuses.Resources))
	sort.Sort(AppSetClusterConditionsSorter(report1.Statuses.ClusterConditions))
	sort.Sort(AppSetClusterResourceSorter(report2.Statuses.Resources))
	sort.Sort(AppSetClusterConditionsSorter(report2.Statuses.ClusterConditions))

	// check equality of resources & cluster conditions
	if !equality.Semantic.DeepEqual(report1.Statuses.Resources, report2.Statuses.Resources) {
		klog.V(1).Info("Resources not same")

		isSame = false
	}

	if !equality.Semantic.DeepEqual(report1.Statuses.ClusterConditions, report2.Statuses.ClusterConditions) {
		klog.V(1).Info("ClusterConditions not same")

		isSame = false
	}

	return isSame
}

func loadAppSetCRD(pathname string) (*appsetreportV1alpha1.AppConditions, error) {
	var (
		err     error
		crddata []byte
		crdobj  appsetreportV1alpha1.AppConditions
	)

	crddata, err = ioutil.ReadFile(filepath.Clean(pathname))

	if err != nil {
		klog.Error("Loading appconditions crd ", err.Error())
		return nil, err
	}

	err = yaml.Unmarshal(crddata, &crdobj)

	if err != nil {
		klog.Error("Unmarshal appconditions crd ", err.Error(), "\n", string(crddata))
		return nil, err
	}

	return &crdobj, nil
}

func ParseNamespacedName(namespacedName string) (string, string) {
	parsedstr := strings.Split(namespacedName, "/")

	if len(parsedstr) != 2 {
		klog.Infof("invalid namespacedName: %v", namespacedName)
		return "", ""
	}

	return parsedstr[0], parsedstr[1]
}

func PrintMemUsage(title string) {
	var m runtime.MemStats

	runtime.ReadMemStats(&m)

	// For info on each, see: https://golang.org/pkg/runtime/#MemStats
	klog.Infof("%v", title)
	klog.Infof("Alloc = %v MiB", bToMb(m.Alloc))
	klog.Infof("\tTotalAlloc = %v MiB", bToMb(m.TotalAlloc))
	klog.Infof("\tSys = %v MiB", bToMb(m.Sys))
	klog.Infof("\tNumGC = %v\n", m.NumGC)
}

func bToMb(b uint64) uint64 {
	return b / 1024 / 1024
}
